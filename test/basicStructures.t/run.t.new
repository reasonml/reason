let run = () => {
  TestUtils.printSection("Basic Structures")
};

while (something) {
  print_string("You're in a while loop");
  print_newline(())
};

for (i in 0 to 5) {
  print_int(i);
  print_newline(());
  for (i in 10 downto 0) {
    print_string("Counting in reverse direction");
    print_newline(())
  }
};

for (i in 0 to expr endOfRangeMustBeSimple soWrap) {
  print_int(i);
  print_newline(());
  for (i in theSame(isTrue, ofThe, startOfRange) downto 0) {
    print_string("Counting in reverse direction");
    print_newline(())
  }
};

let x = (!)(todo Pexp_field;

let x = (!)(todo Pexp_field;

let x = (!)(todo Pexp_send;

let x = (!)(todo Pexp_field;

let x = (!)(todo Pexp_send;

let x = not(todo Pexp_field;

let x = not(todo Pexp_field;

let x = not(todo Pexp_send;

let x = not(todo Pexp_field;

let x = not(todo Pexp_send;

let x = not(not(todo Pexp_field;

let x = (?!)(not(todo Pexp_field;

let x = not((?!)(todo Pexp_field;

let x = (~!)(not(todo Pexp_field;

let x = not((~!)(todo Pexp_field;

let x = (~!)((~!)(todo Pexp_field;

let x = (!!)(todo Pexp_field;

let x = (!!)(todo Pexp_send;

let x = (!~)(todo Pexp_field;

let x = (!~)(todo Pexp_send;

let noParensNeeded = not(todo Pexp_field;

let parensNeededAroundFirst = todo Pexp_field;

let parensNeededAroundSecond = todo Pexp_field;

let noParensNeeded = not(todo Pexp_send;

let parensNeededAroundFirst = todo Pexp_send;

let parensNeededAroundSecond = todo Pexp_send;

let parensWithSpaceNeededAroundFirst = todo Pexp_send;

let parensWithSpaceNeededAroundSecond = todo Pexp_send;

let parensWithSpaceNeededAroundFirst = todo Pexp_send;

let parensWithSpaceNeededAroundSecond = todo Pexp_send;

let x = not(not(todo Pexp_field;

let x = not(not(todo Pexp_send;

let x = -10;

let x = -5.;

let x = Some(-10);

let x = Some(-5.);

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let x = Array.get((!)(arr,0;

let x = Array.get((!)(arr,0;

let x = String.get((!)(str,0;

let x = String.get((!)(str,0;

let x = Array.set((!)(arr,0,1;

let x = Array.set((!)(arr,0,1;

todo Pstr_attribute

todo Pstr_attribute

let /++ = (+);

let something = todo Pexp_ifthenelse;

let logTapSuccess = self => todo Pexp_ifthenelse;

let logTapSuccess = self => todo Pexp_ifthenelse;

todo Pexp_setfield;

todo Pexp_setfield;

todo Pexp_setfield;

todo Pexp_setfield;

todo Pexp_setfield;

let loop = (appTime, frameTime) => todo Pexp_ifthenelse;
appTime process frameTime;

todo Pexp_ifthenelse;

todo Pexp_ifthenelse;

todo Pexp_ifthenelse;

todo Pexp_ifthenelse;

todo Pexp_ifthenelse;

let printIfFirstArgGreater = true;

let result = todo Pexp_ifthenelse;

let myRecord = {
  nestedRecord: {
    anotherNestedRecord: (instaComp, displayRect) => todo Pexp_ifthenelse,
  },
};

todo Pexp_ifthenelse;

todo Pexp_ifthenelse;

(a, b) => todo Pexp_ifthenelse;

todo Pexp_ifthenelse;

todo Pexp_ifthenelse;

todo Pexp_ifthenelse;

todo Pstr_attribute

let x = (10: int);

let x = (10: int);

let (x: int) = 10;

let (x: int) = (10: int);

todo Pstr_attribute

type pairOfInts = other type...;

let (letBindingWithTypeConstraint: int) = 10;

let ((tupleItem: int), (withTypeConstraint: int)) = (
  10,
  20,
);

let _dummyFunc = x => 10;

let annotatingFuncApplication = (
  (_dummyFunc("a"): int),
  (_dummyFunc("a"): int),
);

let annotatingSingleFuncApplication = (
_dummyFunc(
  "a"
): int);

let annotatingSingleFuncApplication =
let a = 100;

let int = 200;
2 + (_dummyFunc(a): int);;;

let (
  (tupleItem: int),
  (constrainedWithoutGrouping: int),
) = (10, 20);

let ((tupleItem, withOutsideTypeConstraint): other type...) = (
  10,
  20,
);

let trailingCommaAccepted = (1, 2);

let moreTrailing = (1, 2, 3, 4, 5, 7);

todo Pstr_attribute

let x = (Pexp_construct list: list(int));

let hd = "appendedToHead";

let tl = Pexp_construct list;

let result = (Pexp_construct cons: list(string));

let result = (Pexp_construct list: list(string));

let recsize = (
  fun
  | [] => 0
  | [hd, ...tl] => 1 + size(tl
);

let recsize = (soFar, lst) =>
switch (lst) {
| [] => 0
| [hd, ...tl] => soFar + 1 size tl
};

let nestedMatch = lstLst =>
switch (lstLst) {
| [hd, ...tl] when false => 10
| [hd, ...tl] =>
  switch (tl) {
  | [] => 0 + 0
  | [tlHd, ...tlTl] => 0 + 1
  }
| [] => 0
};

let nestedMatchWithWhen = lstLst =>
switch (lstLst) {
| [hd, ...tl] when false => 10
| [hd, ...tl] when true =>
  switch (tl) {
  | [] when false => 0 + 0
  | [] when true => 0 + 0
  | [tlHd, ...tlTl] => 0 + 1
  }
| [] => 0
};

todo Pstr_attribute

type mine =
  | MyThing(int)
  | YourThing(int);

let ppp =
  switch (MyThing(20)) {
  | todo: Ppat_alias
  | todo: Ppat_alias => ppp
  };

let todo: Ppat_alias
| todo: Ppat_alias = ppp;

let ppp =
  switch (MyThing(20)) {
  | todo: Ppat_alias
  | todo: Ppat_alias => ppp
  };

let todo: Ppat_alias
| todo: Ppat_alias = ppp;

todo Pstr_attribute

let emptyArray = todo Pexp_array;

let arrayWithOne = todo Pexp_array;

let arrayWithTwo = todo Pexp_array;

let secondItem = Array.get(arrayWithTwo,1;

let secondItem = Array.get(arrayWithTwo,1;

Array.set(arrayWithTwo,1,300;

todo Pstr_attribute

let myString = "asdf";

String.set(myString,2,'9';

let one = 900;

let two = 10000;

let myTuple = ((one: int), (two: int));

type myTupleType = other type...;

let myTuple = (myTuple: myTupleType);

let myTuple = ((
  (one: int),
  (two: int),
): myTupleType);

let addValues = ((a: int), (b: int)) => a + b;

let addValues = ((a: int), (b: int)) => a + b;

let myFunction = ((a: int), (b: int)) => (a + b: int);

let functionReturnValueType = ((i: int), (s: string)) => (x => x + 1: other type...);

let curriedFormOne = ((i: int), (s: string)) => s (^)
string_of_int(
  i
);

let curriedFormTwo = ((i: int), (x: int)) => ((
  i,
  x,
): other type...);

let curriedFormThree = ((i: int), ((
  (a: int),
  (b: int),
): other type...)) => ((
  i,
  a,
  b,
): other type...);

todo Pstr_attribute

type myFuncType = other type...;

let myFunc = ((a, b) => a + b: myFuncType);

let funcWithTypeLocallyAbstractTypes = todo Pexp_newtype;

type a = other type...;

type b =
  | Foo(other type...)
  | Bar(other type..., other type..., other type...)
  | Baz(other type..., other type..., other type...);

type c =
  | Foo(other type...)
  | Bar(other type...);

type d = other type...;

todo Pstr_attribute

type withThreeFields = {
  name: string,
  age: int,
  occupation: string,
};

let testRecord = {
  name: "joe",
  age: 20,
  occupation: "engineer",
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let makeRecordBase = () => {
  name: "Joe",
  age: 30,
  occupation: "Engineer",
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

type props = {
  title: string,
};

type state = unit;

type component = {
  props: props,
};

type component2 = {
  props: props,
  state: state,
  updater: unit,
};

type component3 = {
  props: other type...,
  state: state,
};

type mutableComponent = {
  props: props,
};

type mutabeleComponent2 = {
  props: props,
  state: state,
  style: int,
};

type description = {
  element: string,
  tag: tag(todo a),
};

module Foo = {type bar = {
  foo: other type...,
};};

type foo = {
  bar: other type...,
  qux: qux,
  fooo: other type...,
};

let moreFoo = {bar: Baz.bar, qux, fooo: Fooo.fooo};

let props = {title: "hi"};

let componentA = {props};

let componentB = {props, state: ()};

let foo = {Ppat_record: not supported};

let bar = {Ppat_record: not supported, bar: 1};

let bar = {bar: 1, Ppat_record: not supported};

let bar = {
  Ppat_record: not supported,
  Ppat_record: not supported,
};

{Ppat_record: not supported, y} => 1;


switch (foo) {
| {y: 1, Ppat_record: not supported} => 2
};

let break_after_equal =
no_break_from_here(
  some_call(to_here)
);

let () = todo Pexp_letexception;

{contents: () => ((): unit)};

let z = {a: {b: c, d: e}, f: g};

let z = {a: todo Pexp_extension, f: g};

let z = {a: todo Pexp_object, f: g};

let z = todo Pexp_extension;

let z = todo Pexp_extension;

let z = todo Pexp_extension;

/**
 * Unnecessary parens should be removed.
 */
let unitLambda = () => ();

let identifierLambda = a => ();

let underscoreLambda = _ => ();

"should remove parens" it a => {
  print_string("did it work?");
  print_string("did it work?")
};

(!)(curNode ## childNodes;

foo(preserveBraces => { inCallback};

preserveBraces => { inFirstPos} foo secondArg;


foo(
  oneArg,
  preserveBraces => {
    inFirstPos
  },
  secondArg,
);
