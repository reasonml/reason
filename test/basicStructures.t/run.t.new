let run = () => {
  TestUtils.printSection("Basic Structures")
};

while (something) {
  print_string("You're in a while loop");
  print_newline(())
};

for (i in 0 to 5) {
  print_int(i);
  print_newline(());
  for (i in 10 downto 0) {
    print_string("Counting in reverse direction");
    print_newline(())
  }
};

for (i in 0 to endOfRangeMustBeSimple(expr,soWrap)) {
  print_int(i);
  print_newline(());
  for (i in theSame(isTrue, ofThe, startOfRange) downto 0) {
    print_string("Counting in reverse direction");
    print_newline(())
  }
};

let x = (!)(todo Pexp_field;

let x = (!)(todo Pexp_field;

let x = (!)(foo#bar;

let x = (!)(todo Pexp_field;

let x = (!)((!)(foo#bar;

let x = not(todo Pexp_field;

let x = not(todo Pexp_field;

let x = not(foo#bar;

let x = not(todo Pexp_field;

let x = not(not(foo#bar;

let x = not(not(todo Pexp_field;

let x = (?!)(not(todo Pexp_field;

let x = not((?!)(todo Pexp_field;

let x = (~!)(not(todo Pexp_field;

let x = not((~!)(todo Pexp_field;

let x = (~!)((~!)(todo Pexp_field;

let x = (!!)(todo Pexp_field;

let x = (!!)(foo#bar;

let x = (!~)(todo Pexp_field;

let x = (!~)(foo#bar;

let noParensNeeded = not(todo Pexp_field;

let parensNeededAroundFirst = todo Pexp_field;

let parensNeededAroundSecond = todo Pexp_field;

let noParensNeeded = not(blah#foo#bar;

let parensNeededAroundFirst = not(blah#foo#bar;

let parensNeededAroundSecond = not(blah#foo#bar;

let parensWithSpaceNeededAroundFirst =
not(
  not(blah)
)#foo#bar;

let parensWithSpaceNeededAroundSecond =
not(
  not(blah#foo)
)#bar;

let parensWithSpaceNeededAroundFirst =
(?!)(
  (~+)(blah)
)#foo#bar;

let parensWithSpaceNeededAroundSecond =
(?!)(
  (~+)(blah#foo)
)#bar;

let x = not(not(todo Pexp_field;

let x = not(not(foo#bar;

let x = -10;

let x = -5.;

let x = Some(-10);

let x = Some(-5.);

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let todo: Ppat_lazy = 10;

let x = Array.get((!)(arr,0;

let x = Array.get((!)(arr,0;

let x = String.get((!)(str,0;

let x = String.get((!)(str,0;

let x = Array.set((!)(arr,0,1;

let x = Array.set((!)(arr,0,1;

todo Pstr_attribute

todo Pstr_attribute

let /++ = (+);

let something = if (todo Pexp_field) {
print_string("Did tap");
print_newline(())
} ;

let logTapSuccess = self => if (todo Pexp_field) {
print_string("Did tap");
print_newline(())
} else ();

let logTapSuccess = self => if (todo Pexp_field) {
print_string("Did tap");
print_newline(())
} ;

todo Pexp_setfield;

todo Pexp_setfield;

todo Pexp_setfield;

todo Pexp_setfield;

todo Pexp_setfield;

let loop = (appTime, frameTime) => if (todo Pexp_field) {
setupScene(());
renderIntoTop(());
todo Pexp_setfield
} ;
process(appTime,frameTime);

if (something) {
if (somethingElse) {
()
} else "blah"
} ;

if (something) {
if (somethingElse) {
()
} else "blah"
} ;

if (true) {
if (true) {
print_string("one")
} else print_string("two")
} ;

if (true) {
if (false) {
print_string("one")
} else print_string("two")
} ;

if (false) {
if (true) {
print_string("one")
} else print_string("two")
} ;

let printIfFirstArgGreater = true;

let result = if (printIfFirstArgGreater) {
(a, b) => if (a > b) {
print_string("a > b")
} else print_string("b >= a")
} else if ((a, b) => if (a > b) {
print_string("b < a")
} else print_string("a <= b")) {

print_string(
  "That could never possibly type check"
);
print_newline(())
} ;

let myRecord = {
  nestedRecord: {
    anotherNestedRecord: (instaComp, displayRect) => if (
    Graphics.cgRectIntersectsWithSlop(
      defaultCompositeTimerRectSlop,
      todo Pexp_field,
      displayRect,
    )) {
    IoEligible
    } else IoInelibleButTryComposition,
  },
};

if (printIfFirstArgGreater) {
(a, b) => if (a > b) {
print_string("a > b")
}
} else (a, b) => if (a > b) {
print_string("b < a")
} ;

if (printIfFirstArgGreater) {
(a, b) => if (a > b) {
print_string("a > b")
} else (a, b) => if (a > b) {
print_string("b < a")
}
} ;

(a, b) => if (a > b) { print_string("a > b" } ;

if (printIfFirstArgGreater) {
(a, b) => if (a > b) {
print_string("a > b")
}
} else (a, b) => if (a > b) {
print_string("b < a")
} ;

if (10 < 100) {

let msg = "If there was any doubt, 10 is in fact less than 100.";
print_string(msg);
} else
let msg = "All bets are off.";
print_string(msg);;

if (10 < 100) {

print_string(
  "If there was any doubt, 10 is in fact less than 100."
)
} else print_string("All bets are off.");

todo Pstr_attribute

let x = (10: int);

let x = (10: int);

let (x: int) = 10;

let (x: int) = (10: int);

todo Pstr_attribute

type pairOfInts = other type...;

let (letBindingWithTypeConstraint: int) = 10;

let ((tupleItem: int), (withTypeConstraint: int)) = (
  10,
  20,
);

let _dummyFunc = x => 10;

let annotatingFuncApplication = (
  (_dummyFunc("a"): int),
  (_dummyFunc("a"): int),
);

let annotatingSingleFuncApplication = (
_dummyFunc(
  "a"
): int);

let annotatingSingleFuncApplication =
let a = 100;

let int = 200;
2 + (_dummyFunc(a): int);;;

let (
  (tupleItem: int),
  (constrainedWithoutGrouping: int),
) = (10, 20);

let ((tupleItem, withOutsideTypeConstraint): other type...) = (
  10,
  20,
);

let trailingCommaAccepted = (1, 2);

let moreTrailing = (1, 2, 3, 4, 5, 7);

todo Pstr_attribute

let x = (Pexp_construct list: list(int));

let hd = "appendedToHead";

let tl = Pexp_construct list;

let result = (Pexp_construct cons: list(string));

let result = (Pexp_construct list: list(string));

let recsize = (
  fun
  | [] => 0
  | [hd, ...tl] => 1 + size(tl
);

let recsize = (soFar, lst) =>
switch (lst) {
| [] => 0
| [hd, ...tl] => size(soFar + 1,tl)
};

let nestedMatch = lstLst =>
switch (lstLst) {
| [hd, ...tl] when false => 10
| [hd, ...tl] =>
  switch (tl) {
  | [] => 0 + 0
  | [tlHd, ...tlTl] => 0 + 1
  }
| [] => 0
};

let nestedMatchWithWhen = lstLst =>
switch (lstLst) {
| [hd, ...tl] when false => 10
| [hd, ...tl] when true =>
  switch (tl) {
  | [] when false => 0 + 0
  | [] when true => 0 + 0
  | [tlHd, ...tlTl] => 0 + 1
  }
| [] => 0
};

todo Pstr_attribute

type mine =
  | MyThing(int)
  | YourThing(int);

let ppp =
  switch (MyThing(20)) {
  | todo: Ppat_alias
  | todo: Ppat_alias => ppp
  };

let todo: Ppat_alias
| todo: Ppat_alias = ppp;

let ppp =
  switch (MyThing(20)) {
  | todo: Ppat_alias
  | todo: Ppat_alias => ppp
  };

let todo: Ppat_alias
| todo: Ppat_alias = ppp;

todo Pstr_attribute

let emptyArray = todo Pexp_array;

let arrayWithOne = todo Pexp_array;

let arrayWithTwo = todo Pexp_array;

let secondItem = Array.get(arrayWithTwo,1;

let secondItem = Array.get(arrayWithTwo,1;

Array.set(arrayWithTwo,1,300;

todo Pstr_attribute

let myString = "asdf";

String.set(myString,2,'9';

let one = 900;

let two = 10000;

let myTuple = ((one: int), (two: int));

type myTupleType = other type...;

let myTuple = (myTuple: myTupleType);

let myTuple = ((
  (one: int),
  (two: int),
): myTupleType);

let addValues = ((a: int), (b: int)) => a + b;

let addValues = ((a: int), (b: int)) => a + b;

let myFunction = ((a: int), (b: int)) => (a + b: int);

let functionReturnValueType = ((i: int), (s: string)) => (x => x + 1: other type...);

let curriedFormOne = ((i: int), (s: string)) => s (^)
string_of_int(
  i
);

let curriedFormTwo = ((i: int), (x: int)) => ((
  i,
  x,
): other type...);

let curriedFormThree = ((i: int), ((
  (a: int),
  (b: int),
): other type...)) => ((
  i,
  a,
  b,
): other type...);

todo Pstr_attribute

type myFuncType = other type...;

let myFunc = ((a, b) => a + b: myFuncType);

let funcWithTypeLocallyAbstractTypes = todo Pexp_newtype;

type a = other type...;

type b =
  | Foo(other type...)
  | Bar(other type..., other type..., other type...)
  | Baz(other type..., other type..., other type...);

type c =
  | Foo(other type...)
  | Bar(other type...);

type d = other type...;

todo Pstr_attribute

type withThreeFields = {
  name: string,
  age: int,
  occupation: string,
};

let testRecord = {
  name: "joe",
  age: 20,
  occupation: "engineer",
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let makeRecordBase = () => {
  name: "Joe",
  age: 30,
  occupation: "Engineer",
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

let anotherRecord = {
  name: "joe++",
  age: todo Pexp_field + 10,
};

type props = {
  title: string,
};

type state = unit;

type component = {
  props: props,
};

type component2 = {
  props: props,
  state: state,
  updater: unit,
};

type component3 = {
  props: other type...,
  state: state,
};

type mutableComponent = {
  props: props,
};

type mutabeleComponent2 = {
  props: props,
  state: state,
  style: int,
};

type description = {
  element: string,
  tag: tag(todo a),
};

module Foo = {type bar = {
  foo: other type...,
};};

type foo = {
  bar: other type...,
  qux: qux,
  fooo: other type...,
};

let moreFoo = {bar: Baz.bar, qux, fooo: Fooo.fooo};

let props = {title: "hi"};

let componentA = {props};

let componentB = {props, state: ()};

let foo = {Ppat_record: not supported};

let bar = {Ppat_record: not supported, bar: 1};

let bar = {bar: 1, Ppat_record: not supported};

let bar = {
  Ppat_record: not supported,
  Ppat_record: not supported,
};

{Ppat_record: not supported, y} => 1;


switch (foo) {
| {y: 1, Ppat_record: not supported} => 2
};

let break_after_equal =
no_break_from_here(
  some_call(to_here)
);

let () = todo Pexp_letexception;

{contents: () => ((): unit)};

let z = {a: {b: c, d: e}, f: g};

let z = {a: todo Pexp_extension, f: g};

let z = {a: todo Pexp_object, f: g};

let z = todo Pexp_extension;

let z = todo Pexp_extension;

let z = todo Pexp_extension;

/**
 * Unnecessary parens should be removed.
 */
let unitLambda = () => ();

let identifierLambda = a => ();

let underscoreLambda = _ => ();


it(
  "should remove parens",
  a => {
    print_string("did it work?");
    print_string("did it work?")
  },
);

(!)(curNode ## childNodes;

foo(preserveBraces => { inCallback};

foo(preserveBraces => { inFirstPos},secondArg);


foo(
  oneArg,
  preserveBraces => {
    inFirstPos
  },
  secondArg,
);
