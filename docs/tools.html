<!doctype html>
<html>
<head>
  <link href='https://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">

  <title>Tools</title>

  <!-- Flatdoc -->
  <script src='support/vendor/jquery.js'></script>
  <script src='legacy.js'></script>
  <script src="highlightJs/build/highlight.pack.js"></script>
  <link  href='highlightJs/src/styles/xcode.css' rel='stylesheet'>
  <link rel="stylesheet" href="./octicons/octicons.css">
  <script src='flatdoc.js'></script>


  <!-- Flatdoc theme -->
  <link  href='theme-white/style.css' rel='stylesheet'>
  <script src='theme-white/script.js'></script>
  <link  href='support/theme.css' rel='stylesheet'>
  <script src='support/theme.js'></script>


  <script id="markdown" type="text/markdown" src="index.html">

Tools
==============

Reason-tools
-------

[Reason-tools](https://github.com/reasonml/reason-tools) is a convenient browser
extension for quickly toggling between OCaml syntax and Reason syntax. It also
prettifies the OCaml libraries documentation pages.
[Here](https://reasonml.github.io/reason-tools/popup.html)'s the standalone
version.

Command Line Utilities
-------

The Reason toolchain uses a few important tools that are used in the terminal,
and/or with your editor.

**Note**: the [JavaScript](./jsWorkflow.html#javascript-workflow-editor-setup-global-utilities) 
and [native](./nativeWorkflow.html#native-workflow-editor-setup-global-utilities) 
workflow have different ways of installing  these tools. Please consult their
respective sections for the installation proper. This section only describes
what they are.

### `refmt`

`refmt` takes in your code text and spits it out, nicely formatted. Developers 
use it pervasively to prettify their code, either through invoking it in the
terminal, or through an editor shortcut. It also serves to convert to/from
Reason/OCaml syntax.

`refmt` optionally takes in a column width, and **responsively** formats your 
code based on it. In other words, it doesn't just naively break to the next line
at a certain characters limit; it solves the constrains and arranges your code
accordingly. Here's `refmt` inside Vim, called once per window resize (just to
show the point):

<img src="images/LiquidSmallOptCrop.gif" style="width:100%; max-width:466px; max-height:433px;" />

The Reason community uses it to enforce a consistent style and avoid time-consuming 
manual formatting & stylistic debates.

See `refmt --help` for the options.

### Merlin

[Merlin](https://github.com/ocaml/merlin) provides type hint, refactor, real-
time errors, jump to definitions, etc. to our editors.


Merlin's command line name is called `ocamlmerlin`, though you wouldn't call it
manually (editors start it themselves and query it). To configure Merlin to
understand your project, you'd write a `.merlin` file at the root (documentation
[here](https://github.com/ocaml/merlin/wiki/project-configuration)).

**Note**: For the JS workflow, we generate the `.merlin` file for you, so no
need to worry about it.

Merlin is for OCaml, but has first-class support for Reason. For the support to
work, you'd need the `ocamlmerlin-reason` binary. Again, the installation of
these utilities are described in the [JS Workflow](./jsWorkflow.html#javascript-workflow-editor-setup-global-utilities)
and [Native Workflow](./nativeWorkflow.html#native-workflow-editor-setup-global-utilities)
page.


### REPL

Reason comes with a REPL called `rtop` which lets you interactively evaluate
Reason. It features intelligent, type-driven autocompletion.

<img src="images/RtopOptCrop.gif" style="width:100%; max-width:466px; max-height:433px;">


```sh
# The rtop command begins a REPL session
rtop
```

```sh
let myVar = "Hello Reason!";
# myVar: bytes = "Hello Reason!"

let result = 100 + 200;
# result : int = 300;
```

Use `#quit;` to close your REPL session.

Editor Integration
=======

All our editor integrations provides at minimum:

- Displaying types.
- `refmt`-ing a file.
- Showing errors
- Syntax highlighting.

They're powered by Reason's `refmt` and Merlin, mentioned in the previous sections.

### Atom

You can install the [Atom](https://atom.io/) Reason integration through either
[atom-ocaml-merlin](https://atom.io/packages/ocaml-merlin) or
[Nuclide](https://nuclide.io/). The former is lighter.

<img style="width:100%; max-width:470px; max-height:440px" src="images/NuclideReason.png" />

#### OCaml-Merlin
As per the instructions [here](https://atom.io/packages/ocaml-merlin), you'll also need:

- [language-reason](https://atom.io/packages/language-reason)
- [reason-refmt](https://atom.io/packages/reason-refmt)

As noted on the page, you'll also need the linter (which itself needs Linter-ui-default,
Intention and Busy-signal).

**Note**: if you've installed the global binaries through the [JS Workflow](http://facebook.github.io/reason/jsWorkflow.html#javascript-workflow-project-setup) then you can ignore the `opam install merlin` instructions at the end.

#### Nuclide
- Open the package installer from the menu `Packages > Settings View > Install Packages and Themes`.
- Search for and install `nuclide` if not already installed.
- If you don't want to turn on all of Nuclide's features, you can disable most of it except for:
  - nuclide-ocaml
  - hyperclick
  - autocomplete
  - linter
  - nuclide-code-format
  - nuclide-outline-view
  - nuclide-datatip
  - nuclide-language-reason
  - nuclide-type-hint

We piggy back on Nuclide's facilities (formatting, diagnosis, datatip). `âŒ˜+shift+p` and search for these keywords).

### Vim

The [vim-reason-loader](https://github.com/reasonml/vim-reason-loader) plugin will load the editor support
from wherever `refmt` / `ocamlmerlin` live on the `PATH`. Install it like you would any Vim plugin.

For example, through [NeoBundle](https://github.com/Shougo/neobundle.vim):

```
NeoBundle 'reasonml/vim-reason-loader'
```

Likewise for [vim-plug](https://github.com/junegunn/vim-plug) and others.

`vim-reason-loader` loads the *real*
[vim-reason plugin](https://github.com/facebook/reason/tree/master/editorSupport/VimReason)
from wherever Reason is installed.

<img src="images/VimReason.png" style="width:100%; max-width:470px; max-height:440px" />

#### Merlin

`merlin` has built in `Vim` support.

Completion is provided using `omnifunc`. By default you can trigger it with `<C-X><C-O>` while in insert mode.
If you use completion plugins, most of them can use `omni` as a source.

```
" deoplete

let g:deoplete#omni_patterns = {}
let g:deoplete#omni_patterns.reason = '[^. *\t]\.\w*\|\h\w*|#'
let g:deoplete#sources = {}
let g:deoplete#sources.reason = ['omni', 'buffer']

" neocomplete and YouCompleteMe work out of the box
```

You can use syntactic checks with plugins like Syntastic, ALE, and others.

```
" Syntastic

let g:syntastic_reason_checkers=['merlin']

" ALE

let g:ale_linter_aliases = {'reason': 'ocaml'}
```

`merlin` also provides many helpful commands.
See [this guide](https://github.com/ocaml/merlin/wiki/vim-from-scratch#discovering-the-shiny-features) to learn more. 

#### VimReason

Reason ships with a [syntax plugin](https://github.com/facebook/reason/tree/master/editorSupport/VimReason).
It provides syntax highlighting and formatting.

The command `:ReasonPrettyPrint` invokes the binary `refmt` and formats text in the current buffer.
You can set `g:vimreason_extra_args_expr_reason` variable to control the arguments passed to `refmt` (such as `--print-width`). 

### Emacs

The [Emacs Plugin](https://github.com/facebook/reason/tree/master/editorSupport/emacs)
has the same feature set that the Vim plugin supports.

### VSCode
https://github.com/freebroccolo/vscode-reasonml

### Sublime Text
*Experimental*. Doesn't support Merlin yet!
https://github.com/chenglou/sublime-reason


Integration
======

Reason's included `refmt` program can be used to automatically upgrade part
of your project to Reason's syntax.

#### Upgrade Your Project From OCaml to Reason:

The converted Reason code may attach `[@implicit_arity]` to constructors like `C 1 2 [@implicit_arity]`.
This is due to the fact that OCaml has the ambiguous syntax where a multi-arguments
constructor is expecting argument in a tuple form. So at parsing time we don't
know if `C (1, 2)` in OCaml should be translated to `C (1, 2)` or `C 1 2` in Reason.
By default, we will convert it to `C 1 2 [@implicit_arity]`, which tells the compiler
this can be either `C 1 2` or `C (1, 2)`.

To prevent `[@implicit_arity]` from being generated, one can supply `--assume-explicit-arity`
to `refmt`. This forces the formatter to generate `C 1 2` instead of `C 1 2 [@implicit_arity]`.

However, since `C 1 2` requires multiple arguments, it may fail the compilation if it is actually
a constructor with a single tuple as an argument (e.g., `Some`).
We already have some internal exception rules to cover the common constructors who requires a single tuple
as argument so that they will be converted correctly (e.g., `Some (1, 2)` will be converted
to `Some (1, 2)` instead of `Some 1 2`, which doesn't compile).

To provide your own exception list, create a line-separated file that contains all constructors (without module prefix)
in your project that expects a single tuple as argument, and use `--heuristics-file <filename>`
to tell `refmt` that all constructors
listed in the file will be treated as constructor with a single tuple as argument:

```sh
> cat heuristics.txt
  TupleConstructor
  And
  Or
```

```sh
> cat test.ml
```

```ocaml
type tm =
  TupleConstructor of (int * int)
| MultiArgumentsConstructor of int * int
let x = TupleConstructor(1, 2)
let y = MultiArgumentsConstructor(1, 2)
module Test = struct
  type a = | And of (int * int) | Or of (int * int)
end;;
let a = Test.And (1, 2)
let b = Test.Or (1, 2)
let c = Some (1, 2)
```

Then only the constructor identifiers that were listed will be assumed to accept tuples instead of multiple arguments.

```sh
> refmt --heuristics-file \
    ./heuristics.txt --assume-explicit-arity \
    --parse ml --print re test.ml
```


```reason
  type tm =
    | TupleConstructor of (int, int)
    | MultiArgumentsConstructor of int int;

let x = TupleConstructor (1, 2);
let y = MultiArgumentsConstructor 1 2;
module Test = {
  type a = | And of (int, int) | Or of (int, int);
};
let a = Test.And (1, 2);
let b = Test.Or (1, 2);
let c = Some (1, 2);
```


#### Upgrading Reason Source Code After Changing Parse/Printing:
To upgrade existing Reason code to a new version of the Reason syntax,
you should parse the code with the old version of the parser, and print it with
the new version of the printer. The easiest way to do this is to build the new
version of Reason locally, while the old one is pinned globally, but any way that you
have two versions installed locally will work.

Current Tooling
-----------

#### OCamlBuild
Reason comes with a drop in replacement for `ocamlbuild` called `rebuild`, that
will automatically build any reason file along with your OCaml files, with
no additional configuration. This allows you to add Reason files to your existing
OCaml project bit by bit. Wherever your script refers to `ocamlbuild`, just replace
it with `rebuild`.

#### Makefile
If your build system executes explicit build commands, then the easiest way to
use Reason with `ocamlopt/ocamlc` is by adding the following flags to each
compilation step:

```sh
# intf-suffix tells the compiler where to look for corresponding interface files
ocamlopt -pp refmt -intf-suffix rei -impl myFile.re
ocamlopt -pp refmt -intf myFile.rei
```


Deeper OCaml integration
---------------------------

If you are using `ocamlbuild`, without `rebuild` add the following to your
`_tags` file, but this likely won't be enough because `ocamlc`/`ocamlopt` will
need the `-intf/-impl/-intf-suffix` flags:

```
<**/*.{re,.rei}>: package(reason), syntax(utf8)
```

Credit
-------
The general structure of `refmt` repo was copied from @whitequark's m17n
project, including parts of the `README` that instruct how to use this with the
OPAM toolchain.


  </script>

  <!-- Initializer -->
  <script>
    Flatdoc.run({
      fetcher: function(callback) {
        callback(null, document.getElementById('markdown').innerHTML);
      },
      highlight: function (code, value) {
        return (value === 'reason') ? hljs.highlight('reason', code).value : hljs.highlight(value, code).value;
      },
    });
  </script>

  <!-- Meta -->
  <meta property="og:image" content="./images/CubeRed598_614.png" />
  <meta property="og:image:secure_url" content="./images/CubeRed598_614.png" />
  <meta property="og:image:type" content="image/jpeg" />
  <meta property="og:image:width" content="1196" />
  <meta property="og:image:height" content="1228" />

  <meta content="Reason: Rapid Expressive Systems Programming." name="description">
  <meta content="Reason: Rapid Expressive Systems Programming." property="og:description">
  <!-- <meta content="http://ricostacruz.com/flatdoc/support/preview.jpg" property="og:image"> -->
</head>
<body role='flatdoc' class='big-h3 large-brief'>

  <!-- <div class='title&#45;area title&#45;card' style='background&#45;image: url(support/blur.jpg)'> -->

  <div class='header'>
    <div class='left'>
      <h1><a href='index.html'>Reason</a></h1>
      <ul>
        <li><a href='jsWorkflow.html'>JS Workflow</a></li>
        <li><a href='nativeWorkflow.html'>Native Workflow</a></li>
        <li><a href='tools.html'>Tools</a></li>
        <li><a href='https://github.com/facebook/reason'>GitHub</a></li>
      </ul>
    </div>
  </div>

  <div class='content-root'>
    <div class='menubar'>
      <div class='menu section' role='flatdoc-menu'></div>
    </div>
    <div role='flatdoc-content' class='content'></div>
  </div>

</body>
</html>
